{% extends "parts/base" %}
{%- block title -%}
	Introduction
{%- endblock %}
{% block content %}

<div style="border-top: 1px solid red; border-bottom: 1px solid red; text-align: center; margin-top: 1em; margin-bottom: 1em;">
<p>This article is work in progress. It is incomplete and can contain errors. Help in finishing the article is appreciated.
</p>
</div>
<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Overview"><span class="tocnumber">2</span> <span class="toctext">Overview</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#The_IRG"><span class="tocnumber">3</span> <span class="toctext">The IRG</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#Basic_IRG_Elements"><span class="tocnumber">3.1</span> <span class="toctext">Basic IRG Elements</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Projections"><span class="tocnumber">3.2</span> <span class="toctext">Projections</span></a></li>
</ul>
</li>
</ul>
</td></tr></table>
<h2><span class="mw-headline" id="Introduction"> Introduction </span></h2>
<p>lib<span class="algo">Firm</span> is a C library implementing the <span class="algo">Firm</span> low-level intermediate representation. <span class="algo">Firm</span> is used to represent a computer program in order to analyse and transform it. Its main application is compiler construction where <a class="external text" href="http://pp.info.uni-karlsruhe.de">we</a> use it to represent, optimize and transform C and Java programs to native machine code.
</p><p>The most important features of <span class="algo">Firm</span> are that it is
</p>
<ul><li> low-level which means that the representation of the program is closer to machine code than to the language.
</li><li> completely graph based which means that there are no instruction lists or triple code, only data dependence and control flow graphs.
</li><li> completely <a class="external text" href="http://en.wikipedia.org/wiki/Static_single_assignment_form">SSA</a> based which means that the code of the program is always in SSA form.
</li></ul>
<p>A complete list of <a href="Features" title="Features">Features</a> is also available.
</p><p>In the following, we will try to give you an idea about how programs are presented in <span class="algo">Firm</span>.
</p><p>Firm is using most of the concepts described by Cliff Click. So for a more "scientific" description you might refer to:
</p><p>Click, C. and Paleczny, M. 1995. A simple graph-based intermediate representation. In Papers From the 1995 ACM SIGPLAN Workshop on intermediate Representations (San Francisco, California, United States, January 22 - 22, 1995). ACM, New York, NY, 35-49. <a class="external free" href="http://dx.doi.org/10.1145/202529.202534">http://dx.doi.org/10.1145/202529.202534</a>
</p>
<h2><span class="mw-headline" id="Overview"> Overview </span></h2>
<p>A program (called <i>irp</i> in <a href="/firmw/index.php?title=FirmSpeek&amp;action=edit&amp;redlink=1" class="new" title="FirmSpeek (page does not exist)">FirmSpeek</a>) in lib<span class="algo">Firm</span> consists of three things:
</p>
<ul><li> a type graph
</li><li> a list of IR graphs (<i>irgs</i>) representing the code of the functions in the program
</li><li> a symbol table
</li></ul>
<p>Let us review the type and the IR graphs more closely.
</p><p><br />
</p>
<h2><span class="mw-headline" id="The_IRG"> The IRG </span></h2>
<p>Basically, the irg represents a piece of code. In Firm, this piece of code is called a <i>method</i>. An IRG is a directed graph consisting of IR nodes (<i>irn</i>s) and edges between them. The irns basically represent the flow of control and data in the code to represent. Hence, there are nodes which describe
</p>
<ul><li> basic blocks
</li><li> control transfer instruction like jumps
</li><li> data flow operations such as loads, stores, additions, etc.
</li></ul>
<p>libFirm has several routines to dump irgs to text files in the VCG format. The <a class="external text" href="http://www.info.uni-karlsruhe.de/software.php/id=6&amp;lang=en">yComp</a> Tool is very well suited to visualize these graphs. In the following, we will use these visualizations to present the fundamental concepts of the irgs.
</p>
<h3><span class="mw-headline" id="Basic_IRG_Elements"> Basic IRG Elements </span></h3>
<p>The first irg we will consider is almost minimal. It was constructed by the C frontend of our compiler and represents the code of following C function 
</p>
<pre>
void empty(void) { }
</pre>
<div class="thumb tright"><div class="thumbinner" style="width:338px;"><a href="File:IRG_Empty.png" class="image"><img alt="" src="images/IRG_Empty.png" width="336" height="498" class="thumbimage" /></a>  <div class="thumbcaption">A minimal irg</div></div></div>
<p>You will notice that there are several nodes in different colors with names and numbers. Furthermore, the edges have different colors, line styles and numbers attached. Let us go through all these elements step by step and meet first peculiarities of Firm. 
</p>
<ul><li> Each irn possesses two numbers separated by a colon. The first number is unique in the whole program (irp) the second one is unique in the irg. Being unique in the program eases debugging, since each node can be uniquely identified. Having a number per irg is useful for bitsets, or maps using that number to index elements. Therefore the first number is called the <b>node number</b> and the second one the <b>node index</b>.
</li><li> The two blue nodes <tt>Start</tt> and <tt>End</tt> present the source and sink for all data and control flow. They are the only nodes which are painted in blue so the 'begin' and the 'end' of the program is easy to spot.
</li><li> The light yellow nodes with the label <tt>Block</tt> represent basic blocks in a control flow graph. 
</li><li> Nodes can belong to a basic block. This membership is expressed with the dotted edges. For example, the <tt>End</tt> node belongs to block 1711. The block of the <tt>End</tt> node is called the <b>end block</b> and the block of the <tt>Start</tt> node is called <b>start block</b> respectively.
</li><li> Each block has red edges originating from itself. These edges are control flow edges. Exceptionally, they are drawn in the 'wrong direction'. For example, the <tt>Return</tt> node transfers the control to block 1711 although the edge is drawn in the other direction. This is due to the internal representation of control flow. Each block has an array of control flow predecessor nodes, i.e. nodes that transfer the control to it. The numbers at the control flow edges give the predecessors of a block some order. This will be important when we will consider &#934;-nodes.
</li><li> One rule in Firm says that each block has at least one predecessor. However, this is slightly contrary to the concept of a control flow graph which has exactly one node which is the origin of control flow and has thus no such predecessor. To maintain this rule a control flow self loop is attached to the start block. This loop is from node 1354 to 1358 in the example. (NOTE: This is not true in anymore in latest firm versions, we have to update the image and remove this text then)
</li></ul>
<p><br clear="all" />
</p>
<h3><span class="mw-headline" id="Projections"> Projections </span></h3>
<div class="thumb tright"><div class="thumbinner" style="width:595px;"><a href="File:IRG_Add.png" class="image"><img alt="" src="images/IRG_Add.png" width="593" height="639" class="thumbimage" /></a>  <div class="thumbcaption">A method returning the sum of its two operands</div></div></div>
<p>Drawing the block membership explicitly can lead to very non-concise graphs. Following the familiar drawings of control flow graphs, we thus draw basic blocks as big containers in which all belonging nodes are placed. From now on, we will only draw the graphs this way. 
</p><p>Consider the graph on the right. You might have asked yourself what about these <b>Proj</b> nodes which seem to occur frequently. One of the Firm axioms is that each SSA value corresponds to a node and vice versa. For operations which produce multiple results, this seems to pose a problem. Firm's solution to this problem is to let that operation return a <i>tuple</i> value out of which the results can be <i>projected</i>. This is done with Proj nodes. Note that Tuples can also be nested. In the example graph on the right, the <tt>Start</tt> node returns a tuple out of which three values are projected. Node 1388 projects element 1 from the tuple. Node 1386 projects the element <tt>t_args</tt> from the tuple, which is itself a tuple. It contains all arguments passed to the method this IRG represents. And finally, node 1382 projects the initial control flow (denoted <tt>X_initial_exec</tt>). 
</p><p>Using Proj nodes to handle multiple return values has pros and cons. The biggest con is that a Proj does not resemble a real instruction. The biggest pro is that, using Projs, each SSA value directly corresponds to a node. This makes a lot of things easier when working on the graphs; to address a result without Proj nodes, one would have to maintain a pair (node, result number). Usage of Proj nodes is disputable. Firm chose to have them. 
</p><p>As you can see, the method on the right really does something, in contrast to the last example. Node 1397 adds the both operands given to the method. Its result is returned by the <tt>Return</tt> node 1399.
</p>
{% endblock %}

{% extends "parts/base" %}
{%- block title -%}
	PhaseManagement
{%- endblock %}
{% block content %}

<p>Firm currently has no clear phase management to control the order and dependencies of the optimizations.
This page collects information until someone gets around to implement it.
</p>
<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Requirements"><span class="tocnumber">1</span> <span class="toctext">Requirements</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Consistent_Names"><span class="tocnumber">1.1</span> <span class="toctext">Consistent Names</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Dependencies"><span class="tocnumber">1.2</span> <span class="toctext">Dependencies</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Post_Actions"><span class="tocnumber">1.3</span> <span class="toctext">Post Actions</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Auto_Invalidation"><span class="tocnumber">1.4</span> <span class="toctext">Auto Invalidation</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Clean_Up"><span class="tocnumber">1.5</span> <span class="toctext">Clean Up</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Ordering"><span class="tocnumber">1.6</span> <span class="toctext">Ordering</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Meta"><span class="tocnumber">1.7</span> <span class="toctext">Meta</span></a></li>
</ul>
</li>
</ul>
</td></tr></table>
<h2><span class="mw-headline" id="Requirements"> Requirements </span></h2>
<h3><span class="mw-headline" id="Consistent_Names"> Consistent Names </span></h3>
<p>In cparser there is the "local" optimization,
which directly calls the libFirm function <b>optimize_graph_df</b>.
</p>
<h3><span class="mw-headline" id="Dependencies"> Dependencies </span></h3>
<p>For example ifconv cannot handle Bad nodes in the graph, so they must be removed before. Currently, this is done inline by calling <b>remove_bads</b>. Similarily, the <b>assure_*</b> specify some preconditions. Others are implicit in the order in cparser/driver/firm_opt.c.
</p><p>Here is a list, what an optimization might require
</p>
<ul><li> no floating nodes
</li><li> no unreachable blocks
</li><li> no Bad nodes
</li><li> no critical edges
</li><li> one return (at most)
</li><li> consistent dominance information
</li><li> consistent post-dominance information
</li><li> consistent out edges
</li><li> consistent outs
</li><li> another optimization beforehand
</li><li> assure_cf_loop?
</li><li> assure_irg_entity_usage_computed?
</li><li> assure_irp_globals_entity_usage_computed?
</li></ul>
<h3><span class="mw-headline" id="Post_Actions"> Post Actions </span></h3>
<p>Some optimizations require certain clean up code afterwards.
For example, if-conversion performs "local" and "control-flow" afterwards, according to cparser.
</p><p><i>Matze</i>: I'd like to have some more info on why this is done. It shouldn't be because of correctness... So I'm not sure whether I want an explicit "Post Actions" concept.
</p>
<h3><span class="mw-headline" id="Auto_Invalidation"> Auto Invalidation </span></h3>
<p>Currently, an optimization must explicitly invalidate status information (<b>set_irg_doms_inconsistent</b>).
A more robust approach, would be to invalidate everything by default, such that optimizations must explicitly and dynamically specify, what is still valid.
This prevents that someone forgets to invalidate and just leads to useless recomputation of valid information.
</p>
<h3><span class="mw-headline" id="Clean_Up"> Clean Up </span></h3>
<p>Remove duplicate KeepAlive edges and KeepAlive edges referencing Bad/NoMem.
</p>
<h3><span class="mw-headline" id="Ordering"> Ordering </span></h3>
<p>Currently the phases assume all funktions are completely independet of each other and so perform all optimisations one after the other on each function. Though in the light of inlining the order is suddenly different. We should first completely optimize the leaf functions in a callgraph walking/inlining away towards the callgraph roots...
Needs some discussions on how to do this exactly. One strange effect of this is probably the strange optimization callback from the inliner...
</p><p><i>xt3</i>: That is not true. Currently there are two approaches: local
optimizations run on a graph, independently of other graphs. Global
optimizations run on the ir_prog. The order on which they visit graphs in
completely upon them, the inliner uses for instance the callgraph, other
global optimizations callect global information first and transform the
graphs them (in any order).
</p><p><i>zwinkau</i>: (Inspired by Polyglot) Lazyness for the rescue! When the inliner thinks about inlining a call to X into Y, then X should be fully optimized (recursion!) first and afterwards the inliner decides. Finally, Y is fully optimized.
</p>
<h3><span class="mw-headline" id="Meta"> Meta </span></h3>
<p>Cparser has <b>opt_flags_t</b> for:
</p>
<ul><li> enable the optimization
</li><li> don't dump after transformation 
</li><li> don't verify after transformation
</li><li> do not automatically process -foptions for this transformation
</li><li> output won't work without this pass so we need it even with -O0
</li></ul>

{% endblock %}

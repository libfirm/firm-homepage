{% extends "parts/base" %}
{% block title %}Unreachable Code{% endblock %}
{% block content %}

<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#What_is_unreachable_code"><span class="tocnumber">1</span> <span class="toctext">What is unreachable code</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Detection"><span class="tocnumber">2</span> <span class="toctext">Detection</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Conservatively"><span class="tocnumber">2.1</span> <span class="toctext">Conservatively</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Marking_reachable_blocks"><span class="tocnumber">2.2</span> <span class="toctext">Marking reachable blocks</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-5"><a href="#Pruning"><span class="tocnumber">3</span> <span class="toctext">Pruning</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Caveats"><span class="tocnumber">4</span> <span class="toctext">Caveats</span></a></li>
</ul>
</td></tr></table>
<h1> <span class="mw-headline" id="What_is_unreachable_code"> What is unreachable code </span></h1>
<p>Unreachable Code, is code which cannot be reached (by control-flow) from the beginning of the function. It will consequently never be executed and can be removed.
(Note that unreachable code is dead code because removing it will not change program semantics, but you can also have dead code which is reachable.)
</p><p>By definition the end block is always reachable.
Optimizations that change control flow are responsible for insert keep edges accordingly.
</p>
<h1> <span class="mw-headline" id="Detection"> Detection </span></h1>
<p>We can detect unreachable code in several ways:
</p>
<h3> <span class="mw-headline" id="Conservatively"> Conservatively </span></h3>
<p>A block without any inputs is obviously dead. When removing unreachable code, this usually triggers other blocks to have no inputs and therefore obviously unnecessary. This property will however miss unreachable code that contains loops.
We can easily express this conservative rule as local optimisation.
</p>
<h3> <span class="mw-headline" id="Marking_reachable_blocks"> Marking reachable blocks </span></h3>
<p>This is best done using an optimistic dataflow analysis: If a block has at least one reachable predecessor then it is reachable. If you iterate this until the fixpoint then you have caught all reachable blocks. All other blocks are unreachable. This should catch all cases of unreachable code. This style is one of the things the dataflow analysis in the "combo" phase calculates.
</p><p>The principle of marking all reaching blocks also happens implicitly when we calculate the dominance relation.
So you can identify unreachable blocks in firm by them having a dominance_depth of -1.
</p>
<h1> <span class="mw-headline" id="Pruning"> Pruning </span></h1>
<p>Removing unreachable code means removing a block and all the nodes in it.
This however would mean that we have to remove inputs from blocks.
Removing inputs from blocks is only possible if we remove the same input from all Phi nodes in a block at the exact same time!
As this additionally requires to know all Phi nodes of a block, we use a two-phase approach:
</p><p>The function remove_unreachable_code() uses dominance information to find unreachable code and replaces all unreachable blocks by a special node called <i>Bad</i>.
Nodes within unreachable blocks are also replaced by Bad.
So in effect all unreachable code is replaced by Bad.
Afterwards, only Blocks and Phi nodes have Bad as input values.
</p><p>The function remove_bads() removes Bad inputs by updating the block and all contained Phi nodes at once.
</p>
<h1> <span class="mw-headline" id="Caveats"> Caveats </span></h1>
<p>
libFirm has the invariant that Bad nodes should appear only as operands of blocks or Phi nodes.
This invariant can be violated during an optimization phase but must be hold afterwards.
</p><p>Dominance is not defined for unreachable code. So the SSA-property that a definition dominates its uses does not really apply. I'm not sure yet if this actually causes problems. So far its only a special case in the verifier.
</p>

{% endblock content %}
